{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "CalendarToken Model & Booking calendar_event_id Field",
        "description": "Create the CalendarToken model for per-user OAuth token storage and add the calendar_event_id field to the existing Booking model. This is the foundational data layer required before any calendar provider adapter can function.",
        "details": "1. Create a new `calendars` Django app (or add to existing `providers` module — prefer a new app for clean separation):\n   - `python manage.py startapp calendars` — but given the existing 5-app boundary from backend-planning-brief, add models to the existing `providers` module instead by creating `backend/providers/models.py`.\n\n2. CalendarToken model (`backend/providers/models.py`):\n```python\nclass CalendarToken(models.Model):\n    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='calendar_tokens')\n    provider = models.CharField(max_length=20, choices=[('zoho', 'Zoho'), ('google', 'Google'), ('microsoft', 'Microsoft')])\n    access_token = models.TextField()\n    refresh_token = models.TextField()\n    token_expiry = models.DateTimeField()\n    calendar_id = models.CharField(max_length=500, blank=True, default='', help_text='External calendar ID to sync with')\n    is_active = models.BooleanField(default=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = ('user', 'provider')\n        indexes = [models.Index(fields=['user', 'provider'])]\n```\n\n3. Add `calendar_event_id` to Booking model (`backend/bookings/models.py`):\n```python\ncalendar_event_id = models.CharField(\n    max_length=500, null=True, blank=True,\n    help_text='External calendar event ID for sync'\n)\n```\n\n4. Add `providers` to INSTALLED_APPS in `config/settings.py` (it currently isn't registered as a Django app — it has no `apps.py`). Create `backend/providers/apps.py` with ProvidersConfig.\n\n5. Run `python manage.py makemigrations providers bookings` and `python manage.py migrate`.\n\n6. Add settings for OAuth credentials:\n```python\n# config/settings.py\nZOHO_CLIENT_ID = os.environ.get('ZOHO_CLIENT_ID', '')\nZOHO_CLIENT_SECRET = os.environ.get('ZOHO_CLIENT_SECRET', '')\nZOHO_REDIRECT_URI = os.environ.get('ZOHO_REDIRECT_URI', '')\nGOOGLE_CLIENT_ID = os.environ.get('GOOGLE_CLIENT_ID', '')\nGOOGLE_CLIENT_SECRET = os.environ.get('GOOGLE_CLIENT_SECRET', '')\nGOOGLE_REDIRECT_URI = os.environ.get('GOOGLE_REDIRECT_URI', '')\nMS365_CLIENT_ID = os.environ.get('MS365_CLIENT_ID', '')\nMS365_CLIENT_SECRET = os.environ.get('MS365_CLIENT_SECRET', '')\nMS365_REDIRECT_URI = os.environ.get('MS365_REDIRECT_URI', '')\n```\n\n7. Update `.env.example` with all new calendar OAuth env vars.",
        "testStrategy": "1. Verify migration generates correctly: `python manage.py makemigrations --check`.\n2. Verify CalendarToken can be created with all providers: write a unit test that creates tokens for zoho, google, microsoft providers and asserts unique_together constraint.\n3. Verify Booking.calendar_event_id is nullable and stores external IDs.\n4. Verify the unique_together constraint prevents duplicate (user, provider) combinations.\n5. Test that existing Booking data is unaffected by the new nullable field migration.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-24T14:03:03.515Z"
      },
      {
        "id": "2",
        "title": "Zoho Calendar Adapter Implementation",
        "description": "Implement the ZohoAdapter in backend/providers/zoho_adapter.py with full OAuth2 flow and two-way calendar sync using the Zoho Calendar API. This is the client's primary calendar and highest priority integration.",
        "details": "1. Install `requests` package (add to `requirements.txt`) for HTTP calls to Zoho API.\n\n2. Implement OAuth2 flow in new `backend/providers/views.py`:\n```python\n@api_view(['GET'])\n@permission_classes([IsAuthenticated])\ndef zoho_auth_redirect(request):\n    \"\"\"Redirect user to Zoho OAuth consent screen.\"\"\"\n    state = str(request.user.id)  # Encode user ID in state\n    url = f'https://accounts.zoho.com/oauth/v2/auth?scope=ZohoCalendar.calendar.ALL&client_id={settings.ZOHO_CLIENT_ID}&response_type=code&redirect_uri={settings.ZOHO_REDIRECT_URI}&state={state}&access_type=offline&prompt=consent'\n    return Response({'success': True, 'data': {'authUrl': url}})\n\n@api_view(['GET'])\n@permission_classes([AllowAny])  # Callback from Zoho\ndef zoho_auth_callback(request):\n    \"\"\"Exchange authorization code for tokens, store in CalendarToken.\"\"\"\n    code = request.query_params.get('code')\n    user_id = request.query_params.get('state')\n    # Exchange code for tokens via POST to https://accounts.zoho.com/oauth/v2/token\n    # Store access_token, refresh_token, expiry in CalendarToken\n```\n\n3. Implement ZohoAdapter methods (`backend/providers/zoho_adapter.py`):\n   - `__init__(self, user)`: Accept user to look up CalendarToken\n   - `_get_headers()`: Return Authorization header, auto-refresh if expired\n   - `_refresh_token()`: POST to `https://accounts.zoho.com/oauth/v2/token` with refresh_token grant_type\n   - `create_event(booking_data)`: POST to `https://calendar.zoho.com/api/v1/calendars/{cal_id}/events`\n   - `update_event(external_id, booking_data)`: PUT to same endpoint with event ID\n   - `delete_event(external_id)`: DELETE event\n   - `get_event(external_id)`: GET single event\n   - `list_events(room_id, date)`: GET events for date range\n   - `check_availability(room_id, start, end)`: Use freebusy query\n\n4. Update `BaseProviderAdapter` to accept `user` parameter (optional, backward-compatible with LocalAdapter).\n\n5. Modify `gateway.py` `_load_adapter()` to support per-user adapter instantiation — the gateway should now accept a `user` parameter since each user may have their own OAuth tokens.\n\n6. Update booking creation/update/delete views to pass `request.user` to the provider.\n\n7. Add URL patterns in `backend/providers/urls.py`:\n```python\nurlpatterns = [\n    path('calendar/zoho/auth', zoho_auth_redirect),\n    path('calendar/zoho/callback', zoho_auth_callback),\n]\n```\nInclude in `config/urls.py`.\n\n8. Map Booking fields to Zoho Calendar event fields:\n   - title → summary\n   - description → description\n   - start_time → dateandtime.start (ISO 8601)\n   - end_time → dateandtime.end (ISO 8601)\n   - room.name → location",
        "testStrategy": "1. Unit test OAuth token exchange with mocked HTTP responses (mock `requests.post`).\n2. Unit test token refresh logic — verify expired tokens trigger refresh and CalendarToken is updated.\n3. Unit test create_event maps Booking fields to Zoho API payload correctly.\n4. Unit test error handling when Zoho API returns 401/403/500.\n5. Integration test (with real credentials, in manual testing): verify a booking created in Circle Time appears in Zoho Calendar.\n6. Test that LocalAdapter still works when PROVIDER_MODE=local (no regression).",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Google Workspace Calendar Adapter Implementation",
        "description": "Implement the GoogleAdapter in backend/providers/google_adapter.py with OAuth2 flow and two-way sync using Google Calendar API v3. Second priority after Zoho.",
        "details": "1. Install `google-auth`, `google-auth-oauthlib`, `google-api-python-client` (add to `requirements.txt`).\n\n2. Implement OAuth2 flow in `backend/providers/views.py` (add alongside Zoho):\n```python\n@api_view(['GET'])\n@permission_classes([IsAuthenticated])\ndef google_auth_redirect(request):\n    \"\"\"Redirect user to Google OAuth consent screen.\"\"\"\n    from google_auth_oauthlib.flow import Flow\n    flow = Flow.from_client_config(\n        {'web': {'client_id': settings.GOOGLE_CLIENT_ID, 'client_secret': settings.GOOGLE_CLIENT_SECRET, ...}},\n        scopes=['https://www.googleapis.com/auth/calendar']\n    )\n    flow.redirect_uri = settings.GOOGLE_REDIRECT_URI\n    auth_url, state = flow.authorization_url(access_type='offline', prompt='consent')\n    # Store state → user mapping in session or CalendarToken\n    return Response({'success': True, 'data': {'authUrl': auth_url}})\n\n@api_view(['GET'])\ndef google_auth_callback(request):\n    # Exchange code for tokens, store in CalendarToken(provider='google')\n```\n\n3. Implement GoogleAdapter methods (`backend/providers/google_adapter.py`):\n   - `__init__(self, user)`: Look up CalendarToken(provider='google')\n   - `_get_service()`: Build `googleapiclient.discovery.build('calendar', 'v3', credentials=creds)`\n   - `_refresh_if_needed()`: Use google.auth.transport.requests.Request to refresh\n   - `create_event(booking_data)`: `service.events().insert(calendarId='primary', body=event).execute()`\n   - `update_event(external_id, booking_data)`: `service.events().update(...)`\n   - `delete_event(external_id)`: `service.events().delete(...)`\n   - `list_events(room_id, date)`: `service.events().list(calendarId='primary', timeMin=..., timeMax=...)`\n   - `check_availability(room_id, start, end)`: `service.freebusy().query(...)`\n\n4. Map Booking fields to Google Calendar Event resource:\n   - title → summary\n   - description → description\n   - start_time → start.dateTime (RFC 3339)\n   - end_time → end.dateTime (RFC 3339)\n   - room.name → location\n   - 'Africa/Johannesburg' → start.timeZone, end.timeZone\n\n5. Add URL patterns:\n```python\npath('calendar/google/auth', google_auth_redirect),\npath('calendar/google/callback', google_auth_callback),\n```",
        "testStrategy": "1. Unit test OAuth2 flow with mocked Google API responses.\n2. Unit test GoogleAdapter.create_event builds correct Google Calendar event payload.\n3. Unit test token refresh via google.auth credentials.\n4. Unit test error handling for quota exceeded, invalid credentials, network failures.\n5. Verify CalendarToken(provider='google') is created and updated correctly.\n6. Manual integration test with real Google Workspace account.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "Microsoft 365 / Outlook Calendar Adapter Implementation",
        "description": "Implement a MicrosoftAdapter for Microsoft 365/Outlook calendar sync using Microsoft Graph API with OAuth2 PKCE flow.",
        "details": "1. Install `msal` (Microsoft Authentication Library) — add to `requirements.txt`.\n\n2. Implement OAuth2 flow in `backend/providers/views.py`:\n```python\n@api_view(['GET'])\n@permission_classes([IsAuthenticated])\ndef ms365_auth_redirect(request):\n    import msal\n    app = msal.ConfidentialClientApplication(\n        settings.MS365_CLIENT_ID,\n        authority='https://login.microsoftonline.com/common',\n        client_credential=settings.MS365_CLIENT_SECRET,\n    )\n    auth_url = app.get_authorization_request_url(\n        scopes=['Calendars.ReadWrite'],\n        redirect_uri=settings.MS365_REDIRECT_URI,\n        state=str(request.user.id),\n    )\n    return Response({'success': True, 'data': {'authUrl': auth_url}})\n\n@api_view(['GET'])\ndef ms365_auth_callback(request):\n    # Exchange code for tokens via MSAL\n    # Store in CalendarToken(provider='microsoft')\n```\n\n3. Create `backend/providers/microsoft_adapter.py`:\n```python\nclass MicrosoftAdapter(BaseProviderAdapter):\n    GRAPH_BASE = 'https://graph.microsoft.com/v1.0'\n    \n    def __init__(self, user):\n        self.user = user\n        self.token = CalendarToken.objects.get(user=user, provider='microsoft', is_active=True)\n    \n    def _get_headers(self):\n        self._refresh_if_needed()\n        return {'Authorization': f'Bearer {self.token.access_token}', 'Content-Type': 'application/json'}\n    \n    def create_event(self, booking_data):\n        payload = {\n            'subject': booking_data['title'],\n            'body': {'contentType': 'text', 'content': booking_data.get('description', '')},\n            'start': {'dateTime': booking_data['start'], 'timeZone': 'Africa/Johannesburg'},\n            'end': {'dateTime': booking_data['end'], 'timeZone': 'Africa/Johannesburg'},\n            'location': {'displayName': booking_data.get('room_name', '')},\n        }\n        resp = requests.post(f'{self.GRAPH_BASE}/me/events', json=payload, headers=self._get_headers())\n        resp.raise_for_status()\n        return {'provider': 'microsoft', 'external_id': resp.json()['id']}\n```\n\n4. Update `gateway.py` to support `microsoft` mode:\n```python\nelif mode == 'microsoft':\n    from providers.microsoft_adapter import MicrosoftAdapter\n    return MicrosoftAdapter()\n```\n\n5. Add URL patterns for MS365 OAuth flow.\n\n6. Update `PROVIDER_MODE` docs to include `microsoft` option.",
        "testStrategy": "1. Unit test MSAL token acquisition with mocked responses.\n2. Unit test create_event maps correctly to Microsoft Graph event schema.\n3. Unit test token refresh using MSAL's acquire_token_by_refresh_token.\n4. Test error handling for expired tokens, permissions errors.\n5. Verify CalendarToken(provider='microsoft') storage.\n6. Manual integration test with Microsoft 365 test tenant.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Multi-Calendar Sync Engine & Two-Way Sync",
        "description": "Implement the sync engine that supports syncing bookings to multiple calendar providers simultaneously (differentiator over Fishbowl) and handles inbound calendar changes. Wire calendar sync into booking create/update/delete flows.",
        "details": "1. Refactor the gateway pattern to support multi-provider per user. Instead of a single `PROVIDER_MODE`, support per-user active providers:\n\n```python\n# backend/providers/gateway.py\ndef get_providers_for_user(user) -> list[BaseProviderAdapter]:\n    \"\"\"Return all active calendar adapters for a user.\"\"\"\n    from providers.models import CalendarToken\n    tokens = CalendarToken.objects.filter(user=user, is_active=True)\n    adapters = []\n    for token in tokens:\n        if token.provider == 'zoho':\n            from providers.zoho_adapter import ZohoAdapter\n            adapters.append(ZohoAdapter(user))\n        elif token.provider == 'google':\n            from providers.google_adapter import GoogleAdapter\n            adapters.append(GoogleAdapter(user))\n        elif token.provider == 'microsoft':\n            from providers.microsoft_adapter import MicrosoftAdapter\n            adapters.append(MicrosoftAdapter(user))\n    return adapters if adapters else [LocalAdapter()]\n```\n\n2. Create a sync service (`backend/providers/sync.py`):\n```python\ndef sync_booking_to_calendars(booking, action='create'):\n    \"\"\"Sync a booking to all connected calendars for its organizer.\"\"\"\n    adapters = get_providers_for_user(booking.organizer)\n    results = []\n    for adapter in adapters:\n        try:\n            if action == 'create':\n                result = adapter.create_event(booking_to_event_data(booking))\n                if result.get('external_id'):\n                    # Store mapping: BookingCalendarMapping(booking, provider, external_id)\n                    ...\n            elif action == 'update':\n                mapping = BookingCalendarMapping.objects.get(booking=booking, provider=adapter.provider_name)\n                adapter.update_event(mapping.external_id, booking_to_event_data(booking))\n            elif action == 'delete':\n                mapping = BookingCalendarMapping.objects.get(booking=booking, provider=adapter.provider_name)\n                adapter.delete_event(mapping.external_id)\n        except Exception as e:\n            logger.error(f'Calendar sync failed for {adapter.provider_name}: {e}')\n            results.append({'provider': adapter.provider_name, 'error': str(e)})\n    return results\n```\n\n3. Add `BookingCalendarMapping` model to track per-provider external IDs (since a booking can sync to multiple calendars):\n```python\nclass BookingCalendarMapping(models.Model):\n    booking = models.ForeignKey('bookings.Booking', on_delete=models.CASCADE, related_name='calendar_mappings')\n    provider = models.CharField(max_length=20)\n    external_id = models.CharField(max_length=500)\n    synced_at = models.DateTimeField(auto_now=True)\n    class Meta:\n        unique_together = ('booking', 'provider')\n```\n\n4. Wire sync into booking views (`bookings/views.py`):\n   - `create_booking()`: After `Booking.objects.create()`, call `sync_booking_to_calendars(booking, 'create')`\n   - `update_booking_impl()`: After `booking.save()`, call `sync_booking_to_calendars(booking, 'update')`\n   - `cancel_booking_impl()`: Call `sync_booking_to_calendars(booking, 'delete')`\n\n5. For inbound sync (calendar → bookings), create a management command `sync_from_calendars` or a webhook endpoint:\n```python\n# backend/providers/management/commands/sync_from_calendars.py\n# Polls each user's connected calendars for new/modified events\n# Creates/updates Booking objects for events not originating from Circle Time\n```\n\n6. Add a `source` field to Booking: `source = models.CharField(max_length=20, default='circletime')` to distinguish Circle Time-originated bookings from externally-imported ones.",
        "testStrategy": "1. Unit test that sync_booking_to_calendars calls all active adapters for a user.\n2. Unit test that BookingCalendarMapping is created for each successful sync.\n3. Unit test that sync failures for one provider don't block others.\n4. Test multi-provider scenario: user has both Google and Zoho connected, booking creates events in both.\n5. Test that cancel propagates deletes to all connected calendars.\n6. Test inbound sync creates Booking with source='external'.\n7. Verify LocalAdapter still works as fallback when no tokens exist.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Calendar Integration Frontend (Web)",
        "description": "Build the web UI for managing calendar connections — OAuth connect/disconnect buttons per provider, connection status display, and calendar sync settings in the admin settings page.",
        "details": "1. Create a new API service file `web/src/services/calendar.ts`:\n```typescript\nexport interface CalendarConnection {\n  provider: 'zoho' | 'google' | 'microsoft';\n  isConnected: boolean;\n  calendarId?: string;\n  connectedAt?: string;\n}\n\nexport async function fetchCalendarConnections(): Promise<CalendarConnection[]> { ... }\nexport async function getAuthUrl(provider: string): Promise<string> { ... }\nexport async function disconnectCalendar(provider: string): Promise<void> { ... }\n```\n\n2. Create `web/src/pages/Admin/CalendarSettingsSection.tsx` component (or add section to existing SettingsPage.tsx):\n   - Display cards for each provider (Zoho, Google, Microsoft 365)\n   - Show connection status (Connected/Disconnected) per provider\n   - \"Connect\" button opens OAuth popup/redirect via `getAuthUrl(provider)`\n   - \"Disconnect\" button with confirmation dialog\n   - Show last sync time and calendar name when connected\n\n3. Add calendar connection section to `SettingsPage.tsx` below the existing Business Hours section:\n```tsx\n{/* Calendar Integrations */}\n<div style={sectionCardStyle}>\n  <h2 style={sectionTitleStyle}>Calendar Integrations</h2>\n  <p style={hintStyle}>Connect external calendars for two-way sync. Multiple calendars can be active simultaneously.</p>\n  {providers.map(provider => (\n    <CalendarProviderCard\n      key={provider.id}\n      provider={provider}\n      isConnected={connections[provider.id]?.isConnected}\n      onConnect={() => handleConnect(provider.id)}\n      onDisconnect={() => handleDisconnect(provider.id)}\n    />\n  ))}\n</div>\n```\n\n4. Add a backend endpoint to list user's calendar connections:\n```python\n# GET /api/calendar/connections\n@api_view(['GET'])\n@permission_classes([IsAuthenticated])\ndef list_connections(request):\n    tokens = CalendarToken.objects.filter(user=request.user, is_active=True)\n    return Response({'success': True, 'data': [...]})\n\n# DELETE /api/calendar/connections/<provider>\n@api_view(['DELETE'])\n@permission_classes([IsAuthenticated])\ndef disconnect(request, provider):\n    CalendarToken.objects.filter(user=request.user, provider=provider).delete()\n    return Response({'success': True})\n```\n\n5. Handle the OAuth callback redirect — after the backend stores tokens, redirect to `{FRONTEND_URL}/admin/settings?calendarConnected={provider}`.\n\n6. Add TypeScript types in `web/src/types/calendar.ts`.",
        "testStrategy": "1. Verify calendar connections list renders correctly with 0, 1, and 3 providers connected.\n2. Test connect button redirects to correct OAuth URL for each provider.\n3. Test disconnect button removes the connection and updates UI.\n4. Test OAuth callback redirect shows success message on SettingsPage.\n5. Verify the section only shows for admin users.\n6. Test error states when backend is unreachable.",
        "priority": "medium",
        "dependencies": [
          "2",
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Email Notification System (Reminders, No-Show, Early Release)",
        "description": "Implement Phase 3 email notifications: pre-meeting reminders, no-show notifications to organiser, and room early-release notifications. Leverages the existing SendGrid SMTP configuration already in settings.py.",
        "details": "1. Create a notifications utility module `backend/bookings/notifications.py`:\n```python\nfrom django.core.mail import send_mail\nfrom django.conf import settings\nfrom django.template.loader import render_to_string\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef send_meeting_reminder(booking):\n    \"\"\"Send email reminder to organizer and attendees before meeting.\"\"\"\n    subject = f'Reminder: {booking.title} in {booking.room.name}'\n    context = {\n        'booking': booking,\n        'organizer_name': booking.organizer.name,\n        'room_name': booking.room.name,\n        'start_time': booking.start_time,\n        'checkin_url': f'{settings.FRONTEND_URL}/rooms/{booking.room_id}',\n    }\n    # Send to organizer\n    html_message = render_to_string('bookings/emails/meeting_reminder.html', context)\n    plain_message = f'Your meeting \"{booking.title}\" in {booking.room.name} starts at {booking.start_time:%H:%M}. Please check in on time.'\n    recipients = [booking.organizer.email]\n    # Add attendee emails\n    for attendee in booking.booking_attendees.select_related('user').all():\n        recipients.append(attendee.user.email)\n    try:\n        send_mail(subject, plain_message, settings.DEFAULT_FROM_EMAIL, recipients, html_message=html_message)\n    except Exception as e:\n        logger.error(f'Failed to send reminder for booking {booking.id}: {e}')\n\ndef send_noshow_notification(booking):\n    \"\"\"Notify organizer their booking was marked as no-show.\"\"\"\n    subject = f'No-Show: {booking.title} has been released'\n    plain_message = f'Your booking \"{booking.title}\" in {booking.room.name} was released because nobody checked in within the allowed window.'\n    send_mail(subject, plain_message, settings.DEFAULT_FROM_EMAIL, [booking.organizer.email])\n\ndef send_early_release_notification(booking, freed_minutes):\n    \"\"\"Notify when a room is released early.\"\"\"\n    subject = f'Room Released: {booking.room.name} is now available'\n    plain_message = f'{booking.room.name} was released {freed_minutes} minutes early from \"{booking.title}\". The room is now available for booking.'\n    # Could notify users who have bookings later today in this room, or admins\n    send_mail(subject, plain_message, settings.DEFAULT_FROM_EMAIL, [booking.organizer.email])\n```\n\n2. Create email HTML templates in `backend/bookings/templates/bookings/emails/`:\n   - `meeting_reminder.html`\n   - `noshow_notification.html`\n   - `early_release_notification.html`\n\n3. Create a management command `backend/bookings/management/commands/send_reminders.py`:\n```python\nclass Command(BaseCommand):\n    help = 'Send email reminders for meetings starting within the next N minutes'\n\n    def add_arguments(self, parser):\n        parser.add_argument('--minutes', type=int, default=15, help='Send reminders for meetings starting within N minutes')\n        parser.add_argument('--run-loop', action='store_true')\n\n    def handle(self, *args, **options):\n        # Find confirmed bookings starting within options['minutes'] that haven't had reminders sent\n        # Use a 'reminder_sent' boolean field on Booking OR a separate ReminderLog table\n```\n\n4. Add `reminder_sent = models.BooleanField(default=False)` to Booking model.\n\n5. Wire no-show notification into `auto_release.py` — after marking bookings as no_show, call `send_noshow_notification()` for each.\n\n6. Wire early-release notification into `end_booking()` view in `bookings/views.py` and `meeting_end_early()` in `panel/views.py`.\n\n7. Add notification preferences to OrganisationSettings (optional): `email_reminders_enabled`, `reminder_minutes_before`.",
        "testStrategy": "1. Unit test send_meeting_reminder builds correct email with all attendees.\n2. Unit test send_noshow_notification uses organizer email.\n3. Unit test send_reminders management command finds only upcoming, un-reminded bookings.\n4. Test with Django's `django.core.mail.outbox` in test mode to verify email content and recipients.\n5. Verify auto_release command now sends notifications (mock send_mail, assert called).\n6. Verify end_booking view sends early-release notification.\n7. Test that reminders are not sent for cancelled or already checked-in bookings.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-24T14:08:07.427Z"
      },
      {
        "id": "8",
        "title": "Tablet Extend Meeting & Report Issue (Wire Stubs)",
        "description": "Wire the currently stubbed mobile tablet functions for extending meetings and reporting room issues. The backend extend endpoint already exists; the mobile API service stubs need to be connected. The report issue endpoint needs to be created.",
        "details": "1. **Extend Meeting on Tablet** — The backend `POST /api/bookings/<id>/extend` already works (requires auth). For kiosk/tablet use, create an AllowAny variant in `panel/views.py`:\n```python\n@api_view(['POST'])\n@permission_classes([AllowAny])\ndef meeting_extend(request, meeting_id):\n    \"\"\"Extend meeting from tablet (no auth — kiosk endpoint).\"\"\"\n    try:\n        booking = Booking.objects.get(id=meeting_id)\n    except Booking.DoesNotExist:\n        return Response({'success': False, 'message': 'Meeting not found'}, status=404)\n    \n    extension_minutes = request.data.get('extensionMinutes', 15)\n    # Validate 15-120 min, 15-min increments\n    # Check max extensions (4)\n    # Check conflict with next booking\n    new_end = booking.end_time + timedelta(minutes=extension_minutes)\n    if check_booking_conflicts(booking.room_id, booking.end_time, new_end, exclude_booking_id=booking.id):\n        return Response({'success': False, 'message': 'Cannot extend — next meeting conflict'}, status=409)\n    \n    booking.end_time = new_end\n    booking.save()\n    BookingExtension.objects.create(booking=booking, extension_minutes=extension_minutes)\n    return Response({'success': True, 'data': {'newEndTime': new_end.isoformat(), 'extensionMinutes': extension_minutes}})\n```\n\n2. Add URL: `path('meetings/<uuid:meeting_id>/extend', meeting_extend)` in panel URLs (alongside checkin and end).\n\n3. **Report Issue** — Create endpoint in `panel/views.py`:\n```python\n@api_view(['POST'])\n@permission_classes([AllowAny])\ndef report_issue(request, room_id):\n    \"\"\"Report a room issue from the tablet.\"\"\"\n    description = request.data.get('description', '').strip()\n    if not description:\n        return Response({'success': False, 'message': 'Description is required'}, status=400)\n    try:\n        room = Room.objects.get(id=room_id)\n    except Room.DoesNotExist:\n        return Response({'success': False, 'message': 'Room not found'}, status=404)\n    issue = IssueReport.objects.create(room=room, description=description)\n    return Response({'success': True, 'data': {'id': str(issue.id), 'reportedAt': issue.reported_at.isoformat()}})\n```\n\n4. Add URL: `path('rooms/<uuid:room_id>/report-issue', report_issue)` in panel/config URLs.\n\n5. **Update mobile API service** (`mobile/src/services/api.ts`):\n```typescript\nexport const extendMeeting = async (meetingId: string, minutes: number): Promise<{success: boolean; data?: {newEndTime: string}; message?: string}> => {\n  const res = await fetch(`${API_BASE_URL}/meetings/${meetingId}/extend`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ extensionMinutes: minutes }),\n  });\n  const json = await res.json();\n  return json.success ? { success: true, data: json.data } : { success: false, message: json.message };\n};\n\nexport const reportRoomIssue = async (roomId: string, issue: string): Promise<boolean> => {\n  const res = await fetch(`${API_BASE_URL}/rooms/${roomId}/report-issue`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ description: issue }),\n  });\n  const json = await res.json();\n  return json.success;\n};\n```\n\n6. Add admin endpoint to list/resolve issues: `GET /api/panel/issues`, `PUT /api/panel/issues/<id>/resolve`.",
        "testStrategy": "1. Test POST /api/meetings/<id>/extend returns new end time and creates BookingExtension.\n2. Test extend fails with 409 when next meeting conflicts.\n3. Test extend fails when max 4 extensions reached.\n4. Test POST /api/rooms/<id>/report-issue creates IssueReport.\n5. Test report-issue requires non-empty description.\n6. Verify mobile API functions correctly call new endpoints (manual test on emulator or device).\n7. Test admin issues list endpoint returns all issues.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Production Readiness — Environment Config, WSGI/ASGI, SSL, Secrets",
        "description": "Implement Phase 4 production readiness: environment-based settings split (dev/staging/prod), production server configuration with Gunicorn/Uvicorn, SSL/HTTPS setup, secret key rotation, and database backup scripts.",
        "details": "1. **Split settings into environment-based files** — Refactor `config/settings.py` into:\n   - `config/settings/base.py` — Shared settings (INSTALLED_APPS, MIDDLEWARE, REST_FRAMEWORK, etc.)\n   - `config/settings/development.py` — `from .base import *`, DEBUG=True, CORS_ALLOW_ALL_ORIGINS=True, console email backend\n   - `config/settings/staging.py` — `from .base import *`, DEBUG=False, restricted ALLOWED_HOSTS, real email backend\n   - `config/settings/production.py` — `from .base import *`, DEBUG=False, strict ALLOWED_HOSTS=['Moonstone.local', specific IPs], security settings\n   - Update `DJANGO_SETTINGS_MODULE` to use env var: `os.environ.get('DJANGO_SETTINGS_MODULE', 'config.settings.development')`\n   - Update `manage.py`, `wsgi.py`, `asgi.py` accordingly.\n\n2. **Production security settings** in `production.py`:\n```python\nSECURE_SSL_REDIRECT = True\nSECURE_HSTS_SECONDS = 31536000\nSECURE_HSTS_INCLUDE_SUBDOMAINS = True\nSESSION_COOKIE_SECURE = True\nCSRF_COOKIE_SECURE = True\nSECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')\nSECRET_KEY = os.environ['SECRET_KEY']  # Must be set, no fallback\n```\n\n3. **Gunicorn configuration** — Create `scripts/gunicorn.conf.py`:\n```python\nbind = '0.0.0.0:8000'\nworkers = 4  # 2 * CPU cores + 1\nworker_class = 'uvicorn.workers.UvicornWorker'  # ASGI support\ntimeout = 120\naccesslog = '-'\nerrorloge = '-'\n```\n\n4. **Database backup script** — Create `scripts/backup_db.sh`:\n```bash\n#!/bin/bash\nDATE=$(date +%Y%m%d_%H%M%S)\npg_dump -U $DB_USER -h $DB_HOST $DB_NAME | gzip > /backups/circletime_$DATE.sql.gz\n# Retain last 30 days\nfind /backups -name 'circletime_*.sql.gz' -mtime +30 -delete\n```\n\n5. **Secret key rotation** — Document the process and add a management command:\n```python\n# backend/accounts/management/commands/rotate_secret_key.py\nimport secrets\nclass Command(BaseCommand):\n    def handle(self, *args, **options):\n        new_key = secrets.token_urlsafe(50)\n        self.stdout.write(f'New SECRET_KEY: {new_key}')\n        self.stdout.write('Update your environment variable and restart the server.')\n```\n\n6. **SSL/HTTPS setup** — Create `scripts/generate_ssl_cert.sh` for self-signed LAN certificate:\n```bash\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 \\\n  -keyout /etc/ssl/circletime.key \\\n  -out /etc/ssl/circletime.crt \\\n  -subj '/CN=Moonstone.local'\n```\n\n7. **Nginx reverse proxy config** — Create `scripts/nginx.conf` for SSL termination:\n```nginx\nserver {\n    listen 443 ssl;\n    server_name Moonstone.local;\n    ssl_certificate /etc/ssl/circletime.crt;\n    ssl_certificate_key /etc/ssl/circletime.key;\n    location /api/ { proxy_pass http://127.0.0.1:8000; }\n    location / { root /var/www/circletime/web/dist; try_files $uri /index.html; }\n}\n```\n\n8. Update `.env.example` with all production-relevant variables.",
        "testStrategy": "1. Verify `DJANGO_SETTINGS_MODULE=config.settings.production python manage.py check --deploy` passes with no warnings.\n2. Test that production settings enforce SECRET_KEY from env (no fallback).\n3. Test Gunicorn starts correctly with the config: `gunicorn config.wsgi:application -c scripts/gunicorn.conf.py`.\n4. Test database backup script creates a valid gzip dump that can be restored.\n5. Verify SSL cert generation script produces a valid certificate.\n6. Test nginx config with `nginx -t`.\n7. Verify CORS is correctly restricted in production settings.\n8. Test that development settings still work (backwards compatible).",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Release APK Build Pipeline for Tablets",
        "description": "Set up the build pipeline for generating a signed release APK of the React Native tablet app for deployment to SUNMI M2 MAX tablets. The app must work standalone without Metro bundler or USB connection.",
        "details": "1. **Configure release signing** — Generate a release keystore:\n```bash\nkeytool -genkeypair -v -storetype PKCS12 -keystore mobile/android/app/circletime-release.keystore \\\n  -alias circletime -keyalg RSA -keysize 2048 -validity 10000\n```\n\n2. **Configure Gradle for release signing** — Update `mobile/android/app/build.gradle`:\n```groovy\nandroid {\n    signingConfigs {\n        release {\n            storeFile file('circletime-release.keystore')\n            storePassword System.getenv('KEYSTORE_PASSWORD') ?: ''\n            keyAlias 'circletime'\n            keyPassword System.getenv('KEY_PASSWORD') ?: ''\n        }\n    }\n    buildTypes {\n        release {\n            signingConfig signingConfigs.release\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n            // JS bundle is embedded (no Metro needed)\n        }\n    }\n}\n```\n\n3. **Create build script** — `scripts/build_apk.sh`:\n```bash\n#!/bin/bash\nset -e\ncd mobile\n\n# Set API URL for production\necho 'API_BASE_URL=https://Moonstone.local/api' > .env\n\n# Clean previous builds\ncd android && ./gradlew clean\n\n# Bundle JS (standalone — no Metro needed)\ncd .. && npx react-native bundle \\\n  --platform android \\\n  --dev false \\\n  --entry-file index.js \\\n  --bundle-output android/app/src/main/assets/index.android.bundle \\\n  --assets-dest android/app/src/main/res/\n\n# Build release APK\ncd android && ./gradlew assembleRelease\n\n# Output location\necho \"APK: mobile/android/app/build/outputs/apk/release/app-release.apk\"\n```\n\n4. **Handle .env for production** — Ensure `react-native-dotenv` reads `API_BASE_URL` from the `.env` file at build time (already configured in the project).\n\n5. **SUNMI-specific considerations**:\n   - SUNMI M2 MAX runs Android — standard APK works\n   - No Google Play Services dependency (verify no GMS required)\n   - Set `android:screenOrientation=\"landscape\"` in AndroidManifest.xml if tablets are landscape\n   - Consider auto-start on boot: add a `BootReceiver` BroadcastReceiver in AndroidManifest.xml\n\n6. **Add .gitignore entries** for keystore and APK build outputs.\n\n7. **Document the deployment process** in a deployment section: how to sideload APK to SUNMI M2 via `adb install` or SUNMI's MDM.",
        "testStrategy": "1. Run build script and verify APK is generated without errors.\n2. Install APK on Android emulator — verify it loads without Metro bundler.\n3. Verify the app connects to the configured API_BASE_URL.\n4. Test the pairing flow end-to-end on emulator.\n5. Verify JS bundle is embedded (no network fetch for bundle).\n6. Test that ProGuard doesn't strip needed classes (check for crashes on release build).\n7. If SUNMI hardware available, install and verify full functionality.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "11",
        "title": "GROWORX Branding & Floor Map with Real Room Positions",
        "description": "Apply GROWORX branding throughout the application (web and tablet) using the OrgSettings context, and implement the interactive floor map with real room positions that reflect actual office layout.",
        "details": "1. **GROWORX Branding (Web)** — The OrgSettingsContext already provides `primaryColour`, `orgName`, and `logoUrl`. Wire these into:\n   - `web/src/app/Layout.tsx`: Replace hardcoded 'Circle Time' title with `orgName`, show logo from `logoUrl` in header/sidebar\n   - Apply `primaryColour` as CSS variable `--primary-colour` (already done in OrgSettingsContext.tsx via `applyColour`) — ensure all components reference this variable\n   - Update buttons, links, active states to use `var(--primary-colour)` instead of hardcoded `colors.primary` from theme\n   - Login page: Show org logo and name\n   - Favicon: Document how to replace with GROWORX icon\n\n2. **GROWORX Branding (Tablet)** — Update mobile app to fetch org settings:\n   - Add a fetch to `/api/organisation/settings` on app init (AllowAny endpoint or cache)\n   - Apply `primaryColour` to status indicators, buttons, headers\n   - Show `orgName` and `logoUrl` on idle screen\n\n3. **Floor Map with Real Room Positions** — Enhance `web/src/pages/Booking/FloorMap.tsx`:\n   - Replace placeholder SVG with actual GROWORX office floor plan\n   - Room positions defined as `{ roomId: string, x: number, y: number, width: number, height: number }` overlays on the SVG\n   - Admin configurable: Add a floor map editor in admin (or seed from backend data)\n   - Each room overlay shows:\n     - Room name\n     - Real-time status color (available=green, occupied=red, upcoming=amber)\n     - Click to navigate to room details/booking modal\n   - Fetch room states via existing `/api/rooms` endpoint with status info\n   - Auto-refresh every 30 seconds for live status\n\n4. **Backend support for room positions** — Add position fields to Room model (if not already present):\n```python\n# rooms/models.py\nmap_x = models.FloatField(null=True, blank=True, help_text='X position on floor map (0-100%)')\nmap_y = models.FloatField(null=True, blank=True, help_text='Y position on floor map (0-100%)')\nmap_width = models.FloatField(null=True, blank=True, default=10)\nmap_height = models.FloatField(null=True, blank=True, default=8)\n```\n\n5. Include room map coordinates in the Room serializer response.\n\n6. Add floor map SVG upload in the admin Rooms page or Building management.",
        "testStrategy": "1. Verify org branding loads from backend and applies throughout web UI.\n2. Change primaryColour in admin settings — verify all styled elements update.\n3. Verify logo renders in header and login page when logoUrl is set.\n4. Test floor map renders room overlays at correct positions.\n5. Test room status colors update based on real booking data.\n6. Test clicking a room on the floor map navigates to room details.\n7. Verify mobile app picks up branding (orgName, primaryColour) from API.\n8. Test with empty/null logoUrl — verify graceful fallback.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "Analytics Page Consolidation (4 Pages → 1 Tabbed Page)",
        "description": "Consolidate the four separate analytics pages (Dashboard/KPI, Utilization, Ghosting, Capacity) into a single tabbed page. This is listed as in-progress in the PRD.",
        "details": "1. The current analytics pages are:\n   - `AnalyticsPage.tsx` — KPI dashboard with cards, heatmap, trends\n   - `UtilizationView.tsx` — Per-room utilization charts\n   - `GhostingView.tsx` — No-show rates by room/department\n   - `CapacityView.tsx` — Capacity efficiency analysis\n\n2. Refactor `AnalyticsPage.tsx` to be the unified container with tabs:\n```tsx\nconst TABS = [\n  { id: 'overview', label: 'Overview' },\n  { id: 'utilization', label: 'Utilization' },\n  { id: 'ghosting', label: 'Ghosting' },\n  { id: 'capacity', label: 'Capacity' },\n] as const;\n\ntype TabId = typeof TABS[number]['id'];\n\nexport const AnalyticsPage: React.FC = () => {\n  const [activeTab, setActiveTab] = useState<TabId>('overview');\n  const [dateRange, setDateRange] = useState({ start: ..., end: ... });\n\n  return (\n    <div>\n      <header>Analytics</header>\n      <DateRangePicker value={dateRange} onChange={setDateRange} />\n      <TabBar tabs={TABS} active={activeTab} onChange={setActiveTab} />\n      {activeTab === 'overview' && <OverviewTab dateRange={dateRange} />}\n      {activeTab === 'utilization' && <UtilizationView dateRange={dateRange} />}\n      {activeTab === 'ghosting' && <GhostingView dateRange={dateRange} />}\n      {activeTab === 'capacity' && <CapacityView dateRange={dateRange} />}\n    </div>\n  );\n};\n```\n\n3. Share the DateRangePicker state across all tabs (lift state to parent).\n\n4. Update `Router.tsx` — Remove separate routes for utilization/ghosting/capacity. Keep only `/admin/analytics` route.\n\n5. Update sidebar/navigation — Remove individual analytics sub-links, keep single 'Analytics' link.\n\n6. Ensure each sub-view accepts `dateRange` as a prop instead of managing its own.\n\n7. Add URL hash support for tab persistence: `#utilization` etc.\n\n8. Style tabs using the org primary colour from OrgSettingsContext.",
        "testStrategy": "1. Verify all four tab views render correctly within the single page.\n2. Test tab switching preserves date range selection.\n3. Test URL hash updates when switching tabs.\n4. Test direct navigation to `/admin/analytics#ghosting` opens the correct tab.\n5. Verify old routes (if any existed as direct URLs) redirect properly.\n6. Test that the date range picker filters data across all tabs.\n7. Verify mobile-responsive layout for the tab bar.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-24T08:43:08.623Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-24T14:08:07.429Z",
      "taskCount": 12,
      "completedCount": 3,
      "tags": [
        "master"
      ]
    }
  }
}